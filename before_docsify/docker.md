# Developing / Deploying Docker apps

## Approach to developing/deploying docker apps:
https://blog.docker.com/2015/02/orchestrating-docker-with-machine-swarm-and-compose/

1. Use docker machine to set up 1 or more hosts on your preferred cloud provider (these hosts are then referred as "docker machines")

Eg: [Digital Ocean](https://docs.docker.com/machine/examples/ocean/)
```
docker-machine create --driver digitalocean \
--digitalocean-access-token xxxxx my_machine_name
```

When the Droplet is created, Docker generates a unique SSH key and stores it on your local system in ~/.docker/machines. Initially, this is used to provision the host. Later, it's used under the hood to access the Droplet directly with the docker-machine ssh command.

2. Pool your hosts together using Docker Swarm. You&#39;ll need to create a swarm master and connect one or more swarm nodes to it.

3. Develop your app with Docker Compose. When you&#39;re ready to deploy, have docker-compose talk to your swarm master.

## Tutorials / Books

[The Docker Book](http://www.amazon.com/The-Docker-Book-Containerization-virtualization-ebook/dp/B00LRROTI4)
(kindle)
excelente libro para aprender sobre Docker. Explica los conceptos de manera clara y utiliza ejemplos f√°ciles de seguir.

[Install Docker in Ubuntu](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-getting-started)

[Docker Official Self-Paced Training](https://training.docker.com/self-paced-training)

## Containers

Show all containers:
```
docker ps -a
```

Run container interactively:
```
docker run -i -t image_name /bin/bash
```

Restart a container:
```
docker start my_container_name
```

Attach to a running container:
```
docker exec -it [container\_name] /bin/bash
```

Remove container:
```
docker rm my_container_name
```

Remove all stopped containers:
```
docker container prune
```

## Images

Show all images:
```
docker images
```

Remove an image:
```
docker rmi image_name
```

Remove all dangling images:
```
docker image prune

# Add -a to get rid of all unused images (ones with no containers running them)
docker image prune -a
```

## Volumes

Show all volumes:
```
docker volume ls
```

Remove all dangling volumes:
Note: this will delete your named volumes if no container is currently using it
```
docker volume prune
```

I prefer using a custom `dockerRemoveUntaggedVolumes` alias I set in my bashrc,
which only deletes volumes with a name matching 64 characters (the default name
length generated by docker when you don't assign your volume a name)
```
alias dockerRemoveUntaggedVolumes='docker volume rm $(docker volume ls -qf dangling=true | grep ".\{64\}")'
```

## System prune
```
docker system prune
```
This will remove:
  - all stopped containers
  - all volumes not used by at least one container (even named containers - treat with care)
  - all networks not used by at least one container
  - all dangling images

## Docker Machine

Show all machines:
```
docker-machine ls
```

Activate (select) a machine:
```
docker-machine env machine-name
```

SSH to the active machine:
```
docker-machine ssh
```

## Docker Compose

https://docs.docker.com/compose/

Start app:
```
docker-compose [-f <compose_file.yml>] up
```

Build / re-build image:
```
docker-compose [-f <compose_file.yml>] build <service_name>
docker-compose build web
```

Run a command on an image:
```
docker-compose [-f <compose_file.yml>] run <service_name> <command>
docker-compose run web /bin/bash
```

- How to use persisting volumes, so data can be reused when restarting an app:

Within docker-compose.yml, you can specifiy a named volume to be mounted on a container.

```
# docker-compose.yml
version: '3'

volumes:
  mydatavolume:

services:
  db:
    image: postgres
    volumes:
      - mydatavolume:/var/lib/postgresql/data
```

- How to keep credentials out of docker-compose.yml:

Within docker-compose.yml, you can specify a file that contains the environment variables for the container:

```
# docker-compose.yml
env_file:
    - .env
```

Make sure to add .env to .gitignore, then set the credentials within the .env file like:

```
# .env
SOME_USERNAME=myUser
SOME_PWD_VAR=myPwd
```

You can also specify environment variables on docker-compose.yml, using only the variable key. Environment variables with only a key are resolved to their values on the machine Compose is running on, which can be helpful for secret or host-specific values.

```
# docker-compose.yml
environment:
  RACK_ENV: development
  SESSION_SECRET:
```

- How to use a different config for development and production:

[https://docs.docker.com/v1.7/compose/yml/#extends](https://docs.docker.com/v1.7/compose/yml/#extends)

Extend another service, in the current file or another, optionally overriding configuration.

- How to cache apt-get updates

```
# Dockerfile

# update apt-get
ENV LAST_UPDATED 2016-04-04
RUN apt-get update
```

## Common Errors

[Cannot link to a running container started by docker-compose](http://stackoverflow.com/questions/36489696/cannot-link-to-a-running-container-started-by-docker-compose)

Example error:
docker: Error response from daemon: Cannot link to /my_app_mq_1, as it does not belong to the default network.
